name: CD builds and push to OS registry

# Controls when the action will run. Triggers the workflow on pull requestor push
# events but only for the dev,test,prod branch
on:
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
# if we use the matrix strategy
jobs:
  get-branch-name:
    runs-on: ubuntu-latest
    outputs:
      branch: ${{ steps.extract_branch.outputs.branch }}
    steps:
      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
        id: extract_branch
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    needs: get-branch-name
    environment: ${{ needs.get-branch-name.outputs.branch }}
    steps:
      - name: Extract branch name
        shell: bash
        run: echo "branch=${GITHUB_HEAD_REF:-${GITHUB_REF#refs/heads/}}" >> $GITHUB_OUTPUT
        id: extract_branch
      - uses: actions/checkout@v3
        with:
          ref: ${{ steps.extract_branch.outputs.branch }}
      - name: Cache node modules
        id: cache-npm
        uses: actions/cache@v3
        env:
          cache-name: cache-node-modules
        with:
          # npm cache files are stored in `~/.npm` on Linux/macOS
          path: ~/.npm
          key: ${{ runner.os }}-build-${{ env.cache-name }}-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-build-${{ env.cache-name }}-
            ${{ runner.os }}-build-
            ${{ runner.os }}-
      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "18.x"
          cache: "npm"
          # Since all node modules is stored in the main directory, we need to
          # use the package-lock.json from the main directory
          cache-dependency-path: "./app/package-lock.json"
      - name: Set variables
        shell: bash
        run: |
          echo "SHA=sha-$(git rev-parse --short HEAD)" >> $GITHUB_ENV
          echo "IMAGE_REVISION=$(git rev-parse HEAD)" >> $GITHUB_ENV
          echo "IMAGE_VERSION=main" >> $GITHUB_ENV
      - name: Creates env variables
        env:
          VUE_APP_FRONTEND_BASEPATH: ${{ secrets.VUE_APP_FRONTEND_BASEPATH }}
          VITE_TITLE: ${{ secrets.VITE_TITLE }}
          VITE_CONTACT: ${{ secrets.VITE_CONTACT }}
          VITE_FRONTEND_BASEPATH: ${{ secrets.VITE_FRONTEND_BASEPATH }}
          ENV_PATH: ./app/frontend/.env
        shell: bash
        run: |
          touch $ENV_PATH
          echo VITE_TITLE=$VITE_TITLE >> $ENV_PATH
          echo VITE_CONTACT=$VITE_CONTACT >> $ENV_PATH
          echo VITE_FRONTEND_BASEPATH=$VITE_FRONTEND_BASEPATH >> $ENV_PATH

          echo "cat $ENV_PATH"
          cat $ENV_PATH
      - name: Building image
        id: build-static-image
        uses: redhat-actions/buildah-build@v2
        with:
          image: "medis-rls"
          tags: |
            ${{ steps.extract_branch.outputs.branch}}
            ${{ env.SHA }}
          containerfiles: /Dockerfile
          tls-verify: false
          extra-args: --ulimit nofile=4096:4096
      # Push to specified registry
      - name: Push Static To OpenShift Image repo
        id: push-to-os-static
        uses: redhat-actions/push-to-registry@v2
        with:
          image: ${{ steps.build-static-image.outputs.image }}
          tags: |
            ${{ steps.build-static-image.outputs.tags }}
            ${{ env.SHA }}
          registry: image-registry.apps.silver.devops.gov.bc.ca/${{secrets.OPENSHIFT_TOOLS_SERVER}}
          username: ${{ secrets.OPENSHIFT_TOKEN }}
          password: ${{ secrets.OPENSHIFT_TOKEN }}
      - name: Install oc v4
        uses: redhat-actions/openshift-tools-installer@v1
        with:
          oc: 4
      - name: Authenticate and set context
        uses: redhat-actions/oc-login@v1
        with:
          # URL to your OpenShift cluster.
          # Refer to Step 2.
          openshift_server_url: ${{ secrets.OPENSHIFT_SERVER }}

          # Authentication Token. Can use username and password instead.
          # Refer to Step 3.
          openshift_token: ${{ secrets.OPENSHIFT_DEV_TOKEN }}

          # Disables SSL cert checking. Use this if you don't have the certificate authority data.
          insecure_skip_tls_verify: true

          # Optional - this sets your Kubernetes context's current namespace after logging in.
          namespace: ${{secrets.OPENSHIFT_DEV_SERVER}}
      - name: Start new rollout
        run: oc -n ${{secrets.OPENSHIFT_DEV_SERVER}} rollout restart deployment/medis-rls-app-${{ steps.extract_branch.outputs.branch}}
